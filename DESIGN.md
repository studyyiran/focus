target part
我留下了手动部分。让用户在一周的任何时间，都可以进行，level up操作（当然，这是有最大等级的）。还有成神操作。这是合理的。
因为我需要给用户，绝对的自主性

为了减少自动计算level up的复杂度。我引入之前就想引入的sunny。
sunny每天10个点。来帮助用户保持持续

# 4-14
增加了复活机制。可以将target坟场的东西拉回来。
增加了tree的comments字段（对应的locktype状态）
将levelupbutton的枚举重新设计（对应的修改了接口结构）

## 下是细节描述：
*
* 增加了只能拉取上一周数据，进行数据关联（14天的就需要付费了。再往后就无法关联了。用这种机制帮助每周用户登录留存，也便于查看）




## target page

*  梳理下整个流程
1. 首先是todo
2. 然后todo会关联到target上面
3. targetPage页面渲染button
4. target最终会level up
5. target最终会tree up

* button类别
    * level up   至少完成了一个todo 根据条件，决定是否可以level up。并赋予下一个level comments（缺省的状态下，就默认为最后一个）
    > 目前为手动levelup。不过也可以支持自动levelup。只不过需要加一个level-up锁，来填写如正确的next level的名称。目前简单处理。仅作手动。

---

## tree page
* 点击tree up的时候发生了什么？
    1. 先执行level up的判断条件。
    2. 再执行auto tree的判断条件。（tree结算）
    结算会有两个结果，自动判定。
        1. 上树 上树执行执行自动结算机制。也就是，上树之后，扔到waitList里面，在通过节点上树完成。
        2. 下数 下树是强行执行失败逻辑的树。也就是，通过状态变更，扔到死亡池。
        > 无论是哪种树，用户都需要填写，comments，作为这个target终结的一个描述。

---
因为树一定先执行levelup，这里存在这另外一种交互的可能：
用户点击level up 之后，才进行后续的tree相关的操作。这样ui和逻辑一致性更高。但是目前简单处理，因为没有这方面的需求。
这会很大程度增加复杂度。
level up
mission failed

next level
just tree

on tree
down tree
这会多很多很多的状态
---

* tree页面的东西分为
    0. tree.也就是最直观的树
    > tree里面有waitList
    之前上树，实际上上到了waitList里面。
    只要被填上了comments，就可以从waitList里面，通过拖拽，放到我们最终的树上面。
    1. finish.
    2. fail
    > 对于fail，可以通过支付，来重新开启。需要填写一个comments，这个复活的逻辑，是init所有脏状态 + levelup赋予一个pendding


## 关于自动
1. Todo的关联有期限，每周最后一天，就是本周的todo可以关联的最后期限。
2. 每个月最后一个周的最后一天，会进行结算。对所有的人执行 上树操作，因此会先结算level up 再结算auto tree。
因为执行auto tree就必然会缺省一个comments。而且也因为，这是用户的预期之外的行为（就像是炉石帮我们自动结算每月奖励）因此这个结果需要出现在targetPage页面。以警世人。
所以，这里面有个状态，就叫做lockType。
用户需要填写lockType的comments之后，才能真正的让target得到安息。（这个机制也可以有别的作用，例如，自动结算level up的时候。总之，自动结算，就必须跟上报告呈现。）
目前报告呈现，主要体现在targetPage 因为正式在这里进行状态变更，

---
如果我们每周结算一次（或者，让用户决定auto level up的时间间隔 还有auto tree的时间间隔）
这样的好处是，可以强行控制用户节奏。
但是隐患是：
1. level的含义，会受到置疑。用户会关注，既然level每周结算一次，我也可以手动上level，那么level究竟意味着什么呢？
目前这个版本，level的含义，就是让用户改名用的+用户自己的roadmap。我不想去用任何的auto机制来加在level上面
2. 如果level可以自动+手动添加。那么在上树的时候，上树奖励和level的关系，就变得很暧昧了。你没办法和用户说，
上树是一个大循环，levelup是一个小循环，至于他们的关系，我不确定。
目前就是在说，level，你们自己把控。上树，其实你们也可以自己把控。
我，只负责，去清理那些没人动的tree，还有没人关心的target todo关联问题。（也尽可能努力去让用户经常来。）

修订：
    因为在实现之后我发现，用户其实期待每周的结算。这是一个非常重要的仪式感。因此目前的做法是，将faid的判断，补充回来。至于正常的level up（也就是至少存在一次的）也可以给出一次强行结算，但是目前还没有这么做。

1. 需要人工干预的交互
    1. 每周用户自己确定，所有的todo已经绑定到了target上面，如果超过一周，需要付费解锁（拉每日留存）
    2. 用户根据自己的节奏，进行level up还有tree up的操作

2. auto part
    1. level up 每周日24点，对todo=0，自动执行 手动点击level up逻辑（拉每周留存）
    2. tree 每个月最后一个每周日24点，对16-45天范围内，自动执行 手动点击tree up逻辑（拉每月留存）

其中2.1的设计是有原因的
因为
* todo的生命周期就是day，所以每天我们才会计算delay
* target就是周，这块程序给出target的判定失败，是有节奏的。
* tree就是月，所以每个月，我们会强制结算掉所有的tree。
---


# 4-24
虽然自动还没有解决的很好，但是我把tree画出来了。
这里面也有个过程：第一版的tree，只有节点，没有分数。就感觉很普通，很单薄。但神奇的是，小小的分数，让一切具有了鲜明的意义。
虽然还不够深刻，有意义，但是足够表现出来意思了。

## tree-waitList区域，这块我设计的很满意。
1. 用户完成todo
2. todo关联到target上
3. target进行level up（通过level up判定，并且书写下一个阶段的名称，每一个阶段都尽可能的单一，具体，明确，可以明确的关联上todo，这样才能让target和todo水乳交融）
4. target进行升阶（通过升阶判定，并且书写总结）
5. 升阶之后
    1. 就可以通过treeList拉到。
    2. 也可以通过treeShape拉到，但是是游离节点。
    3. 也可以通过finishTarget拉到，用于追溯和展示（最终的comments，中间的过程，等）

6. 用户可以通过拖拽生成容器，生成容器.(容器上线的原理，是在treeShape的children里面新增的一个节点。)
    >这块写的很艰难，因为mongo不熟悉，我又想省事，就用一个粗暴的treeShape schema表示了。他基本上只有第一个节点有价值。但是也的确让后端存储，处理节点逻辑变得足够ok了。

    >这块我觉得很有创意的是，前端负责渲染，用户的拖拽触发接口调用。
    调用完成后，前端根据新的服务器数据，再次进行渲染（但实际上，所有的前端tree数据，都是后端帮我们布置好了的，这部分代码不需要实现两次）

7. 这时候，用户可以通过，拖动，将游离节点，添加到树上面的任意节点去，同时，可以赋予一个有表意作用的treeName。
    > 这样就补充了treeList的containerNodeId字段，还有treeNodeKeyName字段。
    这两个字段的确非常明确的表达了，一个treeNode应该具有的一切，他的关联容器，他的关联target

8. 然后后端，通过整个treeShape的节点信息，treeList的指向添加上来，还可能targetFinishList来帮助给那些未上树的节点一个名字
    >这块后端写，其实挺好的我个人觉得，一致性比较高，性能比较差。写前端，性能好一些，但是维护性麻烦一点点。还是先省事，性能可以迭代.这是一个前后端配合的很紧密的例子。实现的比较ok。实现效果使用起来，足够了。


这块因为是后端整合，前后端约定了节点类型。
使用targetNode和containerNode，在区分treeList的时候，给出标记。
这样前端可以通过节点类型，完成样式渲染还有交互区分。
包括额外的树节点，也是前端自己维护的。
这是一套灵活性很高的方案。


这种tree输出的方案，需要足够的抽象数据。
之前做失败的，就是因为抽象的复杂度太高了。那样让后端数据，保留前端的渲染，就会变得很复杂。因为所有的渲染，都需要有对应的解析模板。后端也需要去做独立的渲染数据逻辑。两败俱伤。写死前端，就容易多了。



其实整个整合，纯前端实现也可以。
但是我觉得放到后端，更合理，更好一些。不过不好说，前端其实debug更容易一些倒是。但是放前端有重大问题，就是你得拉多个口，才行。所以可以写在node端。
这是属于后端懒得写，最好一个人写完的逻辑；属于接口整个，业务性很强的逻辑，前端自产自销，是好的。这种思路其实可以，后端负责数据库的维护提供稳定的server。node端自己折腾。前端直接消费。挺好的。


## score
score是一个很合理的算法。
* 首先每个成功上树的target都是可以加分的。（这块我不明白。。应该是指基础分）
* 基础完成分5分。只要至少两个level up就可以了。
* 然后一个todo一分。因为todo其实是我们有效的最小单位。
> 分数使用递归计算的方式。也是后端计算好。返回值。前端处理。（甚至如果简单的话，后端直接一行写了，前端还省事）


## 前端交互
1. 使用树状文件结构，表达containr和target的关系，足够的好。这块拖拽闭合的我觉得ok。
    只处理了几种情况
    1. 上树和移动。
    2. container到container的转移。
    3. 新增container
    这里面最棒的一点是，只有扔到container才有效，而且也忽略了顺序等因素，就是按照添加的先后顺序，这样省略了大量的无用的情况，很划算。

2. 然后选中了node节点后，下面会粗暴的列出来对应的踪迹。

这块之前还想过各种复杂的交互。
树啊，
这只是一个展示算法，只需要写一个tree就行了，复杂度可以控制

时间轴啊，
数据都是现成的，只需要给一个有绑定事件的组件就行了

这种交互，的确很重要，但恰好是我觉得，没那么重要的部分。因为核心ok，这部分，就简单了。也就是说，这部分展示效果，对核心基本上毫无影响。我只做，
为了表达核心，最少的view层内容。但他基本上是完整的。




欠缺的
1）改名操作。包括container和target的改名
2）下树基本上没考虑过就。

到此，target基本完成了。还缺少的例如自动执行等部分的代码，可以慢慢添加上来，并不吃紧。
整个东西坐下来，的确对体系有一定的帮助，但是对留存，尤其是连续学习有多大的帮助，就得看了。

4-25
auto条件补充
0）自动levelup 只要 至少有了一天的时间，但是todo.length = 0就fail
1）从上月15到月底的所有都会参与结算（16天-45天的范围） 自动上tree。至少需要2个success + 5个todo（这样的情况保底10分。每多一个todo，就多一分，）
2）tree分数判定。基础分5 * 百分比success / fail（当至少两个成功的时候，才会触发） + 1分 * todo数量

4-30
# season
season的设计很简单，就是通过某种连击系统，让用户坚持来学东西。
season的哲学是春种，夏长（秋收冬藏还在设计）也叫做砸石头。就是用户一点点往前累积往复的学习状态。

season分为两部分，学习和复习。两个如阴阳一样，交替而生。

* slots
    后端的数据结构是以slots为节点进行操作的。


* one by one
    数据是一个study-review。偶数study，基数review。这些都是前端自己塑造出出来的假象。在后端没有任何的相关逻辑。

* lock

    当用户中途有任何一天，简短了，也就是在至少24小时内，没有任何的学习（或复习，这取决于他最后一个动作是什么）
    就会触发lock。不仅自己会进入锁定(宝石会变为黑色)，而且他会退到上一个学习为止。让用户不得不花费更多的惩罚，来找回之前的进度。

    > 这块目前有问题的设计是，用户并不知道每个水晶代表的任何的意义（时间，或者任务是什么，都不清楚），他太抽象了。他表达的仅仅是持续这件
    事情本身，虽然作者认为，目前就这样就够了

* 完成

    当，用户的slots达到一定的轮次（一学，一复习，作为一轮 ）就可以触发完结。完结，会进行分数结算。
    目前的结算方式简单粗暴，就是slots的长度的平方。

* 权衡
    1）是否只能有一条？有几条看玩家自己的能耐。这个没关系。
    2）为何必须1+1？因为这样节奏强。保证了最基本的学习-复习。
    3）是否每天都必须学习呢？这个压力有点大。暂时先这样。

* 未测试的点
    我根本就没有机会测试断点重连，因此这块的功能根本就没有经受推敲。实际上，这也是砸石头的决定性成败点。

# buff
buff是偶然灵机一动的需求。虽然目前完成度也很低。他有两个考量
1. 用户的学习，往往是细碎的，因为很难抽出来完整的时间完成学习。而每一次学习的行为，又没办法从todo进行记录。而这个app的终极使命就是
对你所有的所作所为（包括起床时间，睡眠时间，精神状态，娱乐时间，做爱次数，食物摄取卡洛里，运动次数）都进行记录。高效便捷的记录，是我们的一个
需求吧。因为记录产生意义和粘性。

2. 优质的学习方法，例如吃饭的时候看视频，回想，番茄钟，需要引导。
buff的类别希望做的灵活，高效，有引导作用

3. 流程的难题
目前buff还在测试，他的流程并没有形成。因为我也不清楚，笔墨到底多重才合适。
有一套流程是。
1. 用户先发起学习buff，例如食人魔
2. 用户去执行倒计时
3. 完成倒计时后，用户如果觉得做得还可以，就点击next
4. next里面显示了，过了多少时间，然后提交上面可以再次修改类别和时间
5. 当然也可以不理会，直接新开一个。
但是这显然还需要测试。




# sunny sunny的作用
sunny也属于探索阶段，我想看看数值对于一个工具，究竟有多少的作用。

1. 既然用户连续完成了砸石头，就需要有对应的数值，支撑起来背后的行为
2. 阳光也是用户进行必须操作的底层资源。游戏里面一切都需要阳光。阳光类似于dota传奇的食物，他是推动进度，造成exp差异的根本唯一瓶颈。
3. 阳光也用来约束玩家登陆，天天来，可以获得阳光连击。经常不来，阳光会清空，让你没办法继续使用。
4. 因此阳光也是付费货币。

目前消耗的地方包括
1.当日的todo（提前就护臂不耗费能量）10
2.新增target20（让用户珍惜target）
2.level up 30（level up success的次数，可以影响到分数）
4.上树 40（分数直接影响到分数）

这块的代码写的很不优雅。属于后端维护一套数值+逻辑，前端的数值是自己维护的，但是前端并不发起变更请求，都是靠后端进行运算

# 人物状态
我对于数值有执念。我觉得有意义的数值，才是数值，不然就仅仅是一个难吃的饼。（虽然说石头岛，也是一个数值，也是一个想象。单我仍然觉得有用）
我最开始的梦想，就是希望，有一个10000小时的标准，可以折射成，我现在究竟有多强的感觉。
简单来说，就是一个score——一个等级——对应一个游戏形象
这里面我还加入了一些概念，例如
属性，技能等，都仅仅是尝试性质的。我并不打算真的实现



# season 秋冬