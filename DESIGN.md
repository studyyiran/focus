target part
我留下了手动部分。让用户在一周的任何时间，都可以进行，level up操作（当然，这是有最大等级的）。还有成神操作。这是合理的。
因为我需要给用户，绝对的自主性

为了减少自动计算level up的复杂度。我引入之前就想引入的sunny。
sunny每天10个点。来帮助用户保持持续

4-14
增加了复活机制。可以将target坟场的东西拉回来。
增加了tree的comments字段（对应的locktype状态）
将levelupbutton的枚举重新设计（对应的修改了接口结构）

一下是细节描述：

1）改善上下树的机制。

2）增加了只能拉取上一周数据，进行数据关联（14天的就需要付费了。再往后就无法关联了。用这种机制帮助每周用户登录留存，也便于查看）





梳理下整个流程

1、首先是todo

2、然后todo会关联到target上面

3、targetPage页面渲染button
button类别
1）level up
条件：至少完成了一个todo
根据条件，决定是否可以level up。并赋予下一个level comments（缺省的状态下，就默认为最后一个）

目前为手动levelup。不过也可以支持自动levelup。
只不过需要加一个levelup锁，来填写如正确的next level的名称。
目前简单处理。仅作手动。

2）tree类别
一进来
1）先执行level up的判断条件。
2）再执行auto tree的判断条件。
然后tree分为

上树
上树执行执行自动结算机制。

下数
下树是强行执行失败逻辑的树。

无论是哪种树，用户都需要填写，comments，作为这个target终结的一个描述。

因为树一定先执行levelup，这里存在这另外一种交互的可能：
用户点击level up 之后，才进行后续的tree相关的操作。这样ui和逻辑一致性更高。但是目前简单处理，因为没有这方面的需求。
这会很大程度增加复杂度。
level up
mission failed

next level
just tree

on tree
down tree
这会多很多很多的状态

4、tree
tree页面的东西分为
finish
fail
对于fail，可以通过支付，来重新开启。需要填写一个comments，这个复活的逻辑，是init + levelup



tree里面有waitList
之前上树，实际上上到了waitList里面。
只要被填上了comments，就可以从waitList里面，通过拖拽，放到我们最终的树上面。







关于自动
1）Todo的关联有期限，每周最后一天，就是本周的todo可以关联的最后期限。
2）每个月最后一个周的最后一天，会进行结算。对所有的人执行 上树操作，因此会先结算level up 再结算auto tree。
因为执行auto tree就必然会缺省一个comments。而且也因为，这是用户的预期之外的行为（就像是炉石帮我们自动结算每月奖励）因此这个结果需要出现在targetPage页面。以警世人。
所以，这里面有个状态，就叫做lockType。
用户需要填写lockType的comments之后，才能真正的让target得到安息。（这个机制也可以有别的作用，例如，自动结算level up的时候。总之，自动结算，就必须跟上报告呈现。）

3）这里面有另外一个考量。
如果我们每周结算一次（或者，让用户决定auto level up的时间间隔 还有auto tree的时间间隔）
这样的好处是，可以强行控制用户节奏。
但是隐患是
1）level的含义，会受到置疑。用户会关注，既然level每周结算一次，我也可以手动上level，那么level究竟意味着什么呢？
目前这个版本，level的含义，就是让用户改名用的+用户自己的roadmap。我不想去用任何的auto机制来加在level上面

2）如果level可以自动+手动添加。那么在上树的时候，上树奖励和level的关系，就变得很暧昧了。你没办法和用户说，
上树是一个大循环，levelup是一个小循环，至于他们的关系，我不确定。
目前就是在说，level，你们自己把控。上树，其实你们也可以自己把控。
我，只负责，去清理那些没人动的tree，还有没人关心的target todo关联问题。（也尽可能努力去让用户经常来。）

修订：
    因为在实现之后我发现，用户其实期待每周的结算。这是一个非常重要的仪式感。因此目前的做法是，将faid的判断，补充回来。至于正常的level up（也就是至少存在一次的）也可以给出一次强行结算，但是目前还没有这么做。
    
1. 需要人工干预的交互
    1. 每周用户自己确定，所有的todo已经绑定到了target上面，如果超过一周，需要付费解锁（拉每日留存）
    2. 用户根据自己的节奏，进行level up还有tree up的操作
    
2. auto part
    1. level up 每周日，对todo=0，自动执行 手动点击level up逻辑（拉每周留存）
    2. tree 每个月最后一个每周日，对16-45天范围内，自动执行 手动点击tree up逻辑（拉每月留存）

其中2.1的设计是有原因的
因为
* todo的生命周期就是day，所以每天我们才会计算delay
* target就是周，这块程序给出target的判定失败，是有节奏的。
* tree就是月，所以每个月，我们会强制结算掉所有的tree。

4-24
虽然自动还没有解决的很好，但是我把tree画出来了。

0）第一版的tree，只有节点，没有分数。就感觉很普通，很单薄。但神奇的是，小小的分数，让一切具有了鲜明的意义。
虽然还不够深刻，有意义，但是足够表现出来意思了。

1）tree-waitList区域
这块我设计的很满意。
用户完成todo
todo关联到target上
target进行level up（通过level up判定，并且书写下一个阶段的名称，每一个阶段都尽可能的单一，具体，明确，可以明确的关联上todo，这样才能让target和todo水乳交融）
target进行升阶（通过升阶判定，并且书写总结）
升阶之后，就可以通过treeList拉到。
也可以通过treeShape拉到，但是是游离节点。
也可以通过finishTarget拉到，用于追溯和展示（最终的comments，中间的过程，等）


用户可以通过拖拽生成容器，生成的容器，容器上线的原理，是在treeShape的children里面新增的一个节点。
这块写的很艰难，因为mongo不熟悉，我又想省事，就用一个粗暴的treeShape schema表示了。他基本上只有第一个节点有价值。但是也的确让后端存储，处理节点逻辑变得足够ok了。
这块我觉得很有创意的是，前端负责渲染，用户的拖拽触发接口调用。
调用完成后，前端根据新的服务器数据，再次进行渲染（但实际上，所有的前端tree数据，都是后端帮我们布置好了的，这部分代码不需要实现两次）

这时候，用户可以通过，拖动，将游离节点，添加到树上面的任意节点去，同时，可以赋予一个有表意作用的treeName。（这样就补充了treeList的containerNodeId字段，还有treeNodeKeyName字段。
这两个字段的确非常明确的表达了，一个treeNode应该具有的一切，他的关联容器，他的关联target
）

然后后端，通过整个treeShape的节点信息，treeList的指向添加上来，还可能targetFinishList来帮助给那些未上树的节点一个名字。（这块后端写，其实挺好的我个人觉得，一致性比较高，性能比较差。写前端，性能好一些，但是维护性麻烦一点点。还是先省事，性能可以迭代。）

这是一个前后端配合的很紧密的例子。实现的比较ok。实现效果使用起来，足够了。

这块因为是后端整合，前后端约定了节点类型。
使用targetNode和containerNode，在区分treeList的时候，给出标记。
这样前端可以通过节点类型，完成样式渲染还有交互区分。
包括额外的树节点，也是前端自己维护的。
这是一套灵活性很高的方案。


这种tree输出的方案，需要足够的抽象数据。
之前做失败的，就是因为抽象的复杂度太高了。那样让后端数据，保留前端的渲染，就会变得很复杂。因为所有的渲染，都需要有对应的解析模板。后端也需要去做独立的渲染数据逻辑。两败俱伤。写死前端，就容易多了。



其实整个整合，纯前端实现也可以。
但是我觉得放到后端，更合理，更好一些。不过不好说，前端其实debug更容易一些倒是。但是放前端有重大问题，就是你得拉多个口，才行。所以可以写在node端。
这是属于后端懒得写，最好一个人写完的逻辑；属于接口整个，业务性很强的逻辑，前端自产自销，是好的。这种思路其实可以，后端负责数据库的维护提供稳定的server。node端自己折腾。前端直接消费。挺好的。




2）score
score是一个很合理的算法。
首先每个成功上树的target都是可以加分的。
基础完成分5分。只要至少两个level up就可以了。
然后一个todo一分。因为todo其实是我们有效的最小单位。

分数使用递归计算的方式。也是后端计算好。返回值。前端处理。（甚至如果简单的话，后端直接一行写了，前端还省事）


3）前端交互
使用树状文件结构，表达containr和target的关系，足够的好。这块拖拽闭合的我觉得ok。
只处理了几种情况
1）上树和移动。
2）container到container的转移。
3）新增container
这里面最棒的一点是，只有扔到container才有效，而且也忽略了顺序等因素，就是按照添加的先后顺序，这样省略了大量的无用的情况，很划算。

然后选中了node节点后，下面会粗暴的列出来对应的踪迹。

这块之前还想过各种复杂的交互。
树啊，
这只是一个展示算法，只需要写一个tree就行了，复杂度可以控制

时间轴啊，
数据都是现成的，只需要给一个有绑定事件的组件就行了

这种交互，的确很重要，但恰好是我觉得，没那么重要的部分。因为核心ok，这部分，就简单了。也就是说，这部分展示效果，对核心基本上毫无影响。我只做，
为了表达核心，最少的view层内容。但他基本上是完整的。




欠缺的
1）改名操作。包括container和target的改名
2）下树基本上没考虑过就。

到此，target基本完成了。还缺少的例如自动执行等部分的代码，可以慢慢添加上来，并不吃紧。
整个东西坐下来，的确对体系有一定的帮助，但是对留存，尤其是连续学习有多大的帮助，就得看了。

4-25
auto条件补充
0）自动levelup 只要 至少有了一天的时间，但是todo.length = 0就fail
1）从上月15到月底的所有都会参与结算（16天-45天的范围） 自动上tree。至少需要2个success + 5个todo（这样的情况保底10分。每多一个todo，就多一分，）
2）tree分数判定。基础分5 * 百分比success / fail（当至少两个成功的时候，才会触发） + 1分 * todo数量